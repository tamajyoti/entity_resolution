# AUTOGENERATED! DO NOT EDIT! File to edit: 03-date-features.ipynb (unless otherwise specified).

__all__ = ['clean_spacy_date', 'DateStandardisationVisitor']

# Cell
from collections import Counter

from date_extractor import extract_dates
from dateparser.search import search_dates
from spacy.tokens.span import Span

from .article import Article, Features
from .common import ArticleVisitor


# Cell
def _get_precision(spacy_date_entity: Span, context_size: int = 10) -> str:
    start_ = max(spacy_date_entity.start - context_size, 0)
    end_ = min(spacy_date_entity.end + context_size, len(spacy_date_entity.doc))
    context = str(spacy_date_entity.doc[start_:end_])
    res = extract_dates(context, return_precision=True)
    if len(res) > 1:
        return _get_precision(spacy_date_entity, context_size - 1)
    else:
        return res[0]


def clean_spacy_date(spacy_date_entity: Span, init_context_size: int = 10, dateparser_settings=None) -> dict:
    """
    Extract clean date information from `Spacy` Span object

    The strategy is to use `dateparser.search.search_dates()` to parse the `spaCy` `DATE` tag and then
    use `date_extractor.extract_dates()` to deduce precision. The extraction is validated if both libraries agree
    on the date.

    Parameters
    ----------
    spacy_date_entity: Span,
        spacy extraction associated with `DATE` tag
    init_context_size: int
        length of the context extracted from `spacy_date_entity.doc`. The context is simply the the chunk of `doc`
        between `spacy_date_entity.doc - init_context_size` and `spacy_date_entity.doc + init_context_size`.
    dateparser_settings: dict
        dictionary of settings to pass to `dateparser.search import search_dates()`. Could be useful if we want to
        fiddle with some config options (not fully explored at the moment)

    Returns
    -------
    dict
        the following information are returned:
        * year,month,day: int
            year month and day extracted. Could be `None` if the extraction is untrustworthy for some of the fields.
        * text: str
            The text provided by `spaCy` and used for the extraction
        * validated: bool
            The extraction is validated if both libraries ( ) agree on the date extracted.
        * precision: str
            Precision given by `date_extractor.extract_dates()`; one of `year`, `month` or `day`.

    """
    if dateparser_settings is None:
        dateparser_settings = {}
    date_text = spacy_date_entity.text
    # extract date info first
    date_trust = search_dates(date_text, settings=dateparser_settings)
    if date_trust is not None:
        # extract precision now: we need to give date-extractor some context
        date_check, precision = _get_precision(spacy_date_entity, init_context_size)
        text, date_trust = date_trust[0]

        # validate your extraction by comparing the 2 dates
        month_ = day_ = None
        if precision == "year":
            validated = date_trust.year == date_check.year
            year_ = date_trust.year
        elif precision == "month":
            validated = (date_trust.year == date_check.year) & (date_trust.month == date_check.month)
            year_ = date_trust.year
            month_ = date_trust.month
        else:
            validated = (date_trust.year == date_check.year) & \
                        (date_trust.month == date_check.month) & \
                        (date_trust.day == date_check.day)
            year_ = date_trust.year
            month_ = date_trust.month
            day_ = date_trust.day

        return {"year": year_, "month": month_, "day": day_,
                "text": text, "validated": validated, "precision": precision}


# Cell
class DateStandardisationVisitor(ArticleVisitor):
    # TODO: document the class

    def __init__(self):
        super().__init__()
        self.date_field = Features.DATE

    def visit_article(self, article: Article, init_context_size: int = 10, dateparser_settings=None) -> None:
        if dateparser_settings is None:
            dateparser_settings = {}
        if self.date_field not in article.extracted_entities:
            return
        extracted_dates = article.extracted_entities[self.date_field]
        visitor_results = {}

        # proper parsing starts here
        for date_tag in extracted_dates:
            try:
                date_info = clean_spacy_date(date_tag, init_context_size, dateparser_settings)
            except (IndexError, TypeError):
                # Basically, the code is built in a way that it would crash on certain string, hence we just ignore them
                # TODO fix the stuff when code crashes on something like Thursday, a year ago, and so on.
                continue

            # if feature is actually extracted, update the set and the relevant article
            if date_info is not None:
                visitor_results[date_tag.text] = date_info
        visitor_results = ['-'.join([str(d['year']), str(d['month']), str(d['day'])]) for k, d in
                           visitor_results.items() if d['validated']]
        article.extracted_entities[Features.DATE_CLEAN] = visitor_results
