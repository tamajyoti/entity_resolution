---

title: Exploration


keywords: fastai
sidebar: home_sidebar



nb_path: "03-date-features.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 03-date-features.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<center><strong style="font-size:40px">Date Extraction</strong></center>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The aim of this notebook is to extract date information from text. We will test different python modules and will try to spot the most reliable
one. In a next step, we will integrate the feature extracted in the feature-validation-framework designed for this project.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will also to see how the module performs on <code>spaCy</code> extraction:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="date-extractor-module"><code>date-extractor</code> module<a class="anchor-link" href="#date-extractor-module"> </a></h2><p>The first library we would like to test is <a href="https://github.com/DanielJDufour/date-extractor">date-extractor</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pros:</p>
<ul>
<li>Able to extract precision</li>
</ul>
<p>Cons:</p>

<pre><code>* Extract a lot of noise
* Does not improve in conjunction with 'spaCy'</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="datefinder-module"><code>datefinder</code> module<a class="anchor-link" href="#datefinder-module"> </a></h2><p>The second module we experimented with is <a href="https://github.com/akoumjian/datefinder">datefinder</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pros:</p>
<ul>
<li>Able to not confuse currency with dates</li>
</ul>
<p>Cons:</p>

<pre><code>* Extract some noise
* Does not improve in conjunction with 'spaCy'</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="dateparser-module"><code>dateparser</code> module<a class="anchor-link" href="#dateparser-module"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pros:</p>
<ul>
<li>returns the text used to extract the date</li>
<li>some nice configuration such as locale and default for missing values</li>
<li>Improves on top of <code>spaCy</code></li>
</ul>
<p>Cons:</p>

<pre><code>* Extract a lot of noise if left by itself
* Does not return precision</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Retained-Solution-(for-now)">Retained Solution (for now)<a class="anchor-link" href="#Retained-Solution-(for-now)"> </a></h1><p>I think the combination <code>dateparser</code> + <code>spaCy</code> is the most reliable although it needs to be tested on a larger sample. I also think we can take advantage of <code>date-extractor</code> to extract the precision.</p>
<p>Now we will build a function to the extraction based on the ideas discussed above:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="clean_spacy_date" class="doc_header"><code>clean_spacy_date</code><a href="https://git.uk/machine-learning/data-science-and-statistical-learning/am_combiner/tree/master/am_combiner/features/date.py#L27" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>clean_spacy_date</code>(<strong><code>spacy_date_entity</code></strong>:<code>Span</code>, <strong><code>init_context_size</code></strong>:<code>int</code>=<em><code>10</code></em>, <strong><code>dateparser_settings</code></strong>:<code>dict</code>=<em><code>{}</code></em>)</p>
</blockquote>
<p>Extract clean date information from <code>Spacy</code> Span object</p>
<p>The strategy is to use <code>dateparser.search.search_dates()</code> to parse the <code>spaCy</code> <code>DATE</code> tag and then
use <code>date_extractor.extract_dates()</code> to deduce precision. The extraction is validated if both libraries agree
on the date.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>spacy_date_entity: Span,
    spacy extraction associated with <code>DATE</code> tag
init_context_size: int
    length of the context extracted from <code>spacy_date_entity.doc</code>. The context is simply the the chunk of <code>doc</code>
    between <code>spacy_date_entity.doc - init_context_size</code> and <code>spacy_date_entity.doc + init_context_size</code>.
dateparser_settings: dict
    dictionary of settings to pass to <code>dateparser.search import search_dates()</code>. Could be useful if we want to fiddle with
    some config options (not fully explored at the moment)</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>dict
    the following information are returned:</p>

<pre><code>* year,month,day: int
    year nonth and day extracted. Could be `None` if the extraction is untrusworthy for some of the fields.
* text: str
    The text provided by `spaCy` and used for the extraction
* validated: bool
    The extraction is validated if both libraries ( ) agree on the date extracted.
* precision: str
    Precision given by `date_extractor.extract_dates()`; one of `year`, `month` or `day`.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Visitor-Implementation">Visitor Implementation<a class="anchor-link" href="#Visitor-Implementation"> </a></h1><p>In order to be in-line with the project design, every feature extracted needs to adopt the visitor logic and implement its own <code>Visitor</code> class inheriting from
<code>ArticleVisitor</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DateStandardisationVisitor" class="doc_header"><code>class</code> <code>DateStandardisationVisitor</code><a href="https://git.uk/machine-learning/data-science-and-statistical-learning/am_combiner/tree/master/am_combiner/features/date.py#L89" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DateStandardisationVisitor</code>(<strong><code>track_features</code></strong>:<code>bool</code>=<em><code>False</code></em>) :: <code>ArticleVisitor</code></p>
</blockquote>
<p>This is a abstract class representing a generic visitor.
Class that inherit from it are supposed to be feature extractors which may change the state of the article object.</p>
<h2 id="Attributes">Attributes<a class="anchor-link" href="#Attributes"> </a></h2><p>track_features: bool
    This is a common flag for all visitors indicating if needs to track any of its activities.
    This is up to developer to decide which features to track and how to store them in a class</p>
<h2 id="Methods">Methods<a class="anchor-link" href="#Methods"> </a></h2><p>visit_article(article: Article)
    Concrete implementations of this method will be changing the state of an Article object.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

