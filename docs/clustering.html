---

title: DQS data


keywords: fastai
sidebar: home_sidebar



nb_path: "00_clustering.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_clustering.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<center><strong style="font-size:40px">Clustering</strong></center>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">cluster</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">dfply</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">base_path</span> <span class="o">=</span> <span class="s2">&quot;/home/tarak/Downloads&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dqs_original_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="s2">&quot;dqs_valid_set.csv&quot;</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>

<span class="n">dqs_features_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="s1">&#39;all_vectors_Oct14.pkl&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dqs_features_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
    
<span class="n">unique_names</span> <span class="o">=</span> <span class="n">dqs_original_data</span><span class="o">.</span><span class="n">entity_name</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">dqs_clust_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">unique_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                    <span class="n">dqs_original_data</span><span class="p">[</span><span class="n">dqs_original_data</span><span class="o">.</span><span class="n">entity_name</span> <span class="o">==</span> <span class="n">unique_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">ClusterID</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> \
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_names</span><span class="p">))}</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Just to show how the clustering works, we can quickly fit a K-means algorithm for one name and compute the homogeneity score. Note that here we <em>cheated</em> by reading the number of clusters from the results file:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">entity_name</span> <span class="o">=</span> <span class="s2">&quot;Daniel Sanchez&quot;</span>
<span class="n">n_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">homo_orig</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="n">homo_orig</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1.0</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(15, 8000)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>One question that one may ask at this stage is regarding cluster indices. We have no guarantee that indices coming from the test set and the ones predicted by the clustering algorithm will match. In theory, if the software is smart enough, it should take care of this <em>mapping</em> for us but let's convince ourselves by changing the test indices and recompute the homogeneity metric.</p>
<p>Let's now apply the following mapping to the cluster ids found in the test set:</p>
<ul>
<li>0 -&gt; 8</li>
<li>1 -&gt; 5</li>
<li>2 -&gt; 10</li>
<li>3 -&gt; 9</li>
<li>4 -&gt; 6</li>
<li>5 -&gt; 3</li>
<li>6 -&gt; 1</li>
<li>7 -&gt; 2</li>
<li>8 -&gt; 4</li>
<li>9 - &gt; 7</li>
<li>10 -&gt; 0</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">new_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">4</span><span class="p">])</span>
<span class="n">home_shuffle</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">new_test</span><span class="p">,</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="n">home_shuffle</span> <span class="o">==</span> <span class="n">homo_orig</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>True</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Testing-Framework">Testing Framework<a class="anchor-link" href="#Testing-Framework"> </a></h1><p>We will use the previous dataset to compare the performance of several clustering algorithms. Before we do that, we will provide a function to compute some summary statistics and benchmark the different algorithms. We will also provide a plotting method to visualize the results:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Benchmarking:">Benchmarking:<a class="anchor-link" href="#Benchmarking:"> </a></h2><p>The experience described here is highly inspired from this <a href="https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_digits.html">sklearn-example</a>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">_bench_clust</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;algo&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                         <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">),</span>
                         <span class="s2">&quot;homo&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">estimator</span><span class="o">.</span><span class="n">labels_</span><span class="p">),</span>
                         <span class="s2">&quot;compl&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">completeness_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">estimator</span><span class="o">.</span><span class="n">labels_</span><span class="p">),</span>
                         <span class="s2">&quot;v-meas&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">v_measure_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">estimator</span><span class="o">.</span><span class="n">labels_</span><span class="p">),</span>
                         <span class="s2">&quot;ARI&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">estimator</span><span class="o">.</span><span class="n">labels_</span><span class="p">),</span>
                         <span class="s2">&quot;AMI&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">estimator</span><span class="o">.</span><span class="n">labels_</span><span class="p">)},</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">_bench_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
            <span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;k-means++&quot;</span><span class="p">,</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">KMeans</span><span class="p">,</span>
            <span class="p">(),</span>
            <span class="p">{</span><span class="s2">&quot;init&quot;</span><span class="p">:</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_init&quot;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>algo</th>
      <th>time</th>
      <th>homo</th>
      <th>compl</th>
      <th>v-meas</th>
      <th>ARI</th>
      <th>AMI</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>k-means++</td>
      <td>0.269815</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The next problem we need to solve is how to aggregate the metrics. In fact, we are solving the same problem $n$ times where $n$ is the total number of names found in the test set. Therefore, in order to get a fair overview of the metrics values, we need to aggregate them somehow. The solution suggested here is to use a weighted average where the weight is proportional to number of articles provided. The logic here is that a problem with 1 article is easier to solve than a problem with many articles and hence should be given more weights. Admittedly, we are penalizing our performance metrics but I think it is right as we want out approach to be efficient for complex cases:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">bench_clust</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_entity_name</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">test_data</span><span class="p">):</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="n">_entity_name</span><span class="p">]</span>
        <span class="n">_weight</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># fix n_clusters if needed</span>
        <span class="k">if</span> <span class="s2">&quot;n_clusters&quot;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwds</span><span class="p">[</span><span class="s2">&quot;n_clusters&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">kwds</span><span class="p">[</span><span class="s2">&quot;n_clusters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_res</span> <span class="o">=</span> <span class="n">_bench_clust</span><span class="p">(</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">)</span>
        <span class="n">_res</span> <span class="o">&gt;&gt;=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">entity_name</span> <span class="o">=</span> <span class="n">_entity_name</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_weight</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_res</span><span class="p">)</span>
    
    <span class="c1">## compute summary</span>
    <span class="n">_details</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">metrics</span> <span class="o">=</span>  <span class="n">_details</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">~</span><span class="n">_details</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;algo&quot;</span><span class="p">,</span> <span class="s2">&quot;entity_name&quot;</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">])]</span>
    <span class="n">_summary</span> <span class="o">=</span> <span class="p">{</span><span class="n">metric</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">_details</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">_details</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">}</span>
    <span class="n">_summary</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;algo&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;details&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">_details</span><span class="p">]})</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">_summary</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Our benchmarking framework is tested using the K-means clustering algorithm. The number of clusters is set to a maximum of 10 and will be scaled down if the number of observation is less than that. Note that K-means is not part of the pool of algorithm we consider here. It is just here to test the code:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_kmeans</span> <span class="o">=</span> <span class="n">bench_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">,</span> <span class="s2">&quot;k-means++&quot;</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">KMeans</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;init&quot;</span><span class="p">:</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span> <span class="s2">&quot;n_init&quot;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="n">test_kmeans</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>100%|██████████| 82/82 [00:04&lt;00:00, 18.61it/s]
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>homo</th>
      <th>compl</th>
      <th>v-meas</th>
      <th>ARI</th>
      <th>AMI</th>
      <th>algo</th>
      <th>details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>k-means++</th>
      <td>0.044492</td>
      <td>0.084784</td>
      <td>0.99478</td>
      <td>0.093587</td>
      <td>0.052071</td>
      <td>0.055835</td>
      <td>k-means++</td>
      <td>algo      time          homo     comp...</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Visualization:">Visualization:<a class="anchor-link" href="#Visualization:"> </a></h2><p>The visualization is also inspired from  <a href="https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_digits.html">sklearn-example</a>. We first use PCA to reduce the data and convert to 2D. Then, we apply the clustering algorithm to the reduced data and plot the results. Note that the visualization only applies to a single clustering task (associated to a name):</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">_viz_clust</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">entity_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="c1">#extract the data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> 
    <span class="n">labels</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span>
    
    <span class="c1"># Note: Credit goes to sklean demo page</span>
    <span class="c1"># https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_digits.html</span>
    <span class="c1"># Step size of the mesh. Decrease to increase the quality of the VQ.</span>
    <span class="n">h</span> <span class="o">=</span> <span class="o">.</span><span class="mi">02</span>     <span class="c1"># point in the mesh [x_min, x_max]x[y_min, y_max].</span>

    <span class="c1"># Plot the decision boundary. For that, we will assign a color to each</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

    <span class="c1"># Obtain labels for each point in mesh. Use last trained model.</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

    <span class="c1"># Put the result into a color plot</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
               <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xx</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
               <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Paired</span><span class="p">,</span>
               <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;k.&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Plot the centroids as a white X</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centroids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">169</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> clustering on the </span><span class="si">{</span><span class="n">entity_name</span><span class="si">}</span><span class="s2"> dataset (PCA-reduced data)</span><span class="se">\n</span><span class="s2"> Centroids are marked with white cross&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(())</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(())</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">entity_name</span> <span class="o">=</span> <span class="s2">&quot;Daniel Sanchez&quot;</span>
<span class="n">n_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">_viz_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">,</span> 
           <span class="n">entity_name</span><span class="p">,</span>
           <span class="s2">&quot;k-means++&quot;</span><span class="p">,</span>
           <span class="n">cluster</span><span class="o">.</span><span class="n">KMeans</span><span class="p">,</span>
           <span class="p">(),</span>
           <span class="p">{</span><span class="s2">&quot;init&quot;</span><span class="p">:</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_init&quot;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Clustering-Algos">Clustering Algos<a class="anchor-link" href="#Clustering-Algos"> </a></h1><p>Most of the example in this section is highly inspired from <a href="https://hdbscan.readthedocs.io/en/latest/comparing_clustering_algorithms.html">hdbscan</a> package documentation</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Affinity-Propagation:">Affinity Propagation:<a class="anchor-link" href="#Affinity-Propagation:"> </a></h2><p>Affinity Propagation is the first algorithm we explore. It is a graph based approach that does not require the user to specify the number of clusters. However, it has also some challenges:</p>
<ul>
<li>Selection of <code>preference</code> and <code>damping</code> could be challenging. Default values in <code>sklean</code> usually over estimate the number of clusters.</li>
<li>Slow to compute</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_aff_propa</span> <span class="o">=</span> <span class="n">bench_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">,</span> <span class="s2">&quot;aff-propa&quot;</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">AffinityPropagation</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;preference&quot;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="s2">&quot;damping&quot;</span><span class="p">:</span><span class="mf">0.99</span><span class="p">,</span> 
                                                                                            <span class="s2">&quot;random_state&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
                            <span class="p">)</span>
<span class="n">test_aff_propa</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>  0%|          | 0/82 [00:00&lt;?, ?it/s]/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
 10%|▉         | 8/82 [00:00&lt;00:00, 79.61it/s]/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
 21%|██        | 17/82 [00:00&lt;00:00, 81.50it/s]/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
 76%|███████▌  | 62/82 [00:00&lt;00:00, 82.55it/s]/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
 87%|████████▋ | 71/82 [00:00&lt;00:00, 81.73it/s]/home/tarak/anaconda3/envs/am_combiner/lib/python3.8/site-packages/sklearn/cluster/_affinity_propagation.py:134: UserWarning: All samples have mutually equal similarities. Returning arbitrary cluster center(s).
  warnings.warn(&#34;All samples have mutually equal similarities. &#34;
100%|██████████| 82/82 [00:01&lt;00:00, 81.27it/s]
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>homo</th>
      <th>compl</th>
      <th>v-meas</th>
      <th>ARI</th>
      <th>AMI</th>
      <th>algo</th>
      <th>details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>aff-propa</th>
      <td>0.003993</td>
      <td>0.986617</td>
      <td>0.784613</td>
      <td>0.845017</td>
      <td>0.245805</td>
      <td>0.253011</td>
      <td>aff-propa</td>
      <td>algo      time  homo     compl    v-m...</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mean-Shift">Mean Shift<a class="anchor-link" href="#Mean-Shift"> </a></h2><p>Another option when don't know/want to specify the number of clusters is the Mean shift algorithm. The underlying idea of the Mean Shift algorithm is that there exists some probability density function from which the data is drawn, and tries to place centroids of clusters at the maxima of that density function. It approximates this via kernel density estimation techniques, and the key parameter is then the bandwidth of the kernel used and hence can be also slow. If not provided, <code>bandwith</code> can be estimated using <code>sklearn.cluster.estimate_bandwidth</code> (see <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MeanShift.html">documentation</a> for more details):</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_mean_shift</span> <span class="o">=</span> <span class="n">bench_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">,</span> <span class="s2">&quot;mean-shift&quot;</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">MeanShift</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;cluster_all&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;bandwidth&quot;</span><span class="p">:</span> <span class="mf">0.991</span><span class="p">})</span>
<span class="n">test_mean_shift</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>100%|██████████| 82/82 [00:04&lt;00:00, 17.83it/s]
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>homo</th>
      <th>compl</th>
      <th>v-meas</th>
      <th>ARI</th>
      <th>AMI</th>
      <th>algo</th>
      <th>details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>mean-shift</th>
      <td>0.057938</td>
      <td>0.992491</td>
      <td>0.796216</td>
      <td>0.856077</td>
      <td>0.332309</td>
      <td>0.348482</td>
      <td>mean-shift</td>
      <td>algo      time  homo     compl    v-...</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="DBSCAN">DBSCAN<a class="anchor-link" href="#DBSCAN"> </a></h2><p><code>DBSCAN</code> is a density based algorithm, it assumes clusters for dense regions. As a first step <code>DBSCAN</code> transforms the space according to the density of the data: points in dense regions are left alone, while points in sparse regions are moved further away. Applying single linkage clustering to the transformed space results in a dendrogram, which we cut according to a distance parameter (called epsilon or <code>eps</code> in many implementations) to get clusters.</p>
<p><strong>Note</strong>: any singleton clusters at that cut level are deemed to be <code>noise</code> and left unclustered.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dbscan</span> <span class="o">=</span> <span class="n">bench_clust</span><span class="p">(</span><span class="n">dqs_clust_data</span><span class="p">,</span> <span class="s2">&quot;dbscan&quot;</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">DBSCAN</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;eps&quot;</span><span class="p">:</span><span class="mf">1.34</span><span class="p">,</span> <span class="s2">&quot;min_samples&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="n">dbscan</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>100%|██████████| 82/82 [00:01&lt;00:00, 71.26it/s]
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>homo</th>
      <th>compl</th>
      <th>v-meas</th>
      <th>ARI</th>
      <th>AMI</th>
      <th>algo</th>
      <th>details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>dbscan</th>
      <td>0.005889</td>
      <td>0.434759</td>
      <td>0.924003</td>
      <td>0.536916</td>
      <td>0.213239</td>
      <td>0.235104</td>
      <td>dbscan</td>
      <td>algo      time      homo     compl    v-...</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Conlustion">Conlustion<a class="anchor-link" href="#Conlustion"> </a></h2><p>After experimenting with 10+ different clustering algorithms (not all reported here), it seems that 2 of them maybe more appropriate for this specific problem:</p>
<ul>
<li>Affinity propagation</li>
<li>Mean shift</li>
</ul>
<p>These 2 algorithms do not need the user to decide beforehand on the number of clusters. However, they may benefit from fine tuning their parameters. Given the size of our test set, this may not be possible and hence we will need to rely on arbitrary selected values.</p>

</div>
</div>
</div>
</div>
 

